[
    {
        "page": 1,
        "text": "IIR Digital Filter 설계\n왕 윤 성 저.\n(dhkd119@daum.net)\n투마이북"
    },
    {
        "page": 2,
        "text": "판권 페이지\nIIR Digital Filter 설계\n지 은 이 왕 윤 성\n 출 판 사 투마이북\n 출 판 일 2013/08/20\n 판매가격 3000원\n ISBN번호 979-11-950399-5-1\n 이 메 일 dhkd119@daum.net\n책 소 개\nPython 언어의 풍부한 라이브러리 중 Matplotlib를\n사용하여 실무에서 쓸 수 있는 IIR Digital Filter를\n설계하는 방법을 기술하였다.\n저자소개\n부경대학교 전자공학과 졸업\n03'05~12'02 넥스트칩\n12'03~12'12 이타칩스\n13'01~현재 어보브반도체"
    },
    {
        "page": 3,
        "text": "차 례\n1. 설계 환경 구축하기\n1.1 Python 설치하기\n1.2 Scipy 설치하기\n1.3 Numpy 설치하기\n1.4 Matplotlib 설치하기\n2. Python으로 IIR 필터 설계하기\n2.1 IIR 필터의 정의\n2.2 사양(Specification) 정하기\n2.3 주파수 특성그래프 이해하기\n2.4 Python으로 필터 설계하기\n2.5 계수에 대해 양자화하기\n2.6 Group Delay 특성보기\n3. Verilog로 IIR 필터 설계하기\n3.1 IIR 필터의 하드웨어 구조\n3.2 Verilog 전체코드 분석하기\n3.3 Testbench 분석\n4. Appendix A\n이 책은 KoPob 서체를 사용하고 있습니다.\nKoPub 서체의 지적재산권은 문화체육관광부와\n한국출판인회의에 있습니다."
    },
    {
        "page": 4,
        "text": "1. 설계 환경 구축하기\n무언가를 하려고 하면 꼭 환경이 갖춰지지 않아 포기하는\n경우가 많다. 우리는 필터를 설계하기 위해 국내에 잘 알려져\n있지 않은 python 이라는 언어를 선택했다. 따라서\npython언어로 필터를 설계하려면 본인의 PC에 python\n언어를 컴파일 할 수 있는 프로그램이 설치되어 있어야 한다.\n이 장에서는 python과 필터에 필요한 패키지를 설치하는\n방법을 소개한다. 참고로 python은 인터프리터 언어이다."
    },
    {
        "page": 5,
        "text": "1.1 Python 설치하기\nPython(파이션) 은 현재 2.7.5 가 최신 버젼이다. 이 최신\n버젼을 다운 받기 위해, www.python.org 파이션 공식\n홈페이지를 방문한다.\n홈페이지에서 왼쪽을 보면 'DOWNLOAD'가 있는데\n'Download'을 클릭하고 다운로드 사이트로 이동한다."
    },
    {
        "page": 6,
        "text": "아래 그림은 파이션 다운로드 사이트이다. 여기서 'python\n2.7.5 windows installer'를 다운받아 PC에 설치하도록\n한다. 설치할 때에는 설정을 기본으로 두고 설치하길 바란다.\npython search\nAdvanced Search\n30 Download\nABOUT Download Python\nNEWS 3\nThe current production versions are Python 2.7.5 and Python 3.3.2.\nDOCUMENTATION\nDOWNLOAD\nStart with one of these versions for leaming Python or IT you want the most stability, they're both considered stable\nLicense\nproduction releases.\nReleases\nWindows\nif you don't know which version to use. try Python 3.3. Some existing third-party software is not yet compatible with\nMacintosh\nOther Python 3: ir you need to use such software, you can download Python 2.7.x Instead.\nSource\nFor the MD5 checksums and OpenPGP signatures, look at the detailed Python 3 3 2 page:\n下载 30\nCOMMUNITY 30\n· Python 3.3.2 Windows x86 MSI Installer (Windows binary -- does not include source)\nFOUNDATION 30 [1] - does not include\n· Python 3.3.2 Windows X86-64 MSI Installer (Windows AMD64 / Intel 64 1 X86-64 binary\nCORE DEVELOPMENT source)\n· Python 3.3 2 Mac OS X 64-bit/32-bit x86-64/1386 Installer (for Mac OS X 10 6 and later (2)\nPython Wiki\n· Python 3.3.2 Mac os X 32-bit 1386/PPC Installer (for Mac os X 10.5 and later [2]\nPython Insider Blog\n· Python 3.3.2 bzipped source tarball (for Linux. Unix or Mac OS X)\nPython 2 or 3?\n· Python 3.3 2 xzipped source tarball (for Linux, Unix or Mac OS X, better compression)\nHelp Fund Python\nPayPal For the MD5 checksums and OpenPGP signatures, look at the detailed Python 2.7.5 page:\n· Python 2.7.5 Windows Installer (Windows binary  does not include source)\n· Python 2. 7.5 Windows X86-64 Installer (Windows AMD64 / Intel 64 / X86- 64 binary [1] does not include source)\n· Python 2.7.5 Mac os X 64-bit/32-bit x86-64/1386 Installer (for Mac os X 10. 6 and later [2]\nNon-English Resources\n· Python 2.7.5 Mac OS X 32-bit I386/PPC Installer (for Mac OS X 10.3 and later [2])\n· Python 2.7.5 compressed source tarball (Tor Linux, Unix or Mac OS X)\ntelease Schedule\n· Python 2.7 5 bzipped source tarball (for Linux, Unix or Mac OS X, more compressed)\n여기서 한가지 주의할 점은 다운 받을 때, 32bit installer\n를 다운 받아야 한다. 패키지 중 64bit을 지원하지 않는\n패키지가 있을 수 있기 때문이다."
    },
    {
        "page": 7,
        "text": "1.2 Scipy 설치하기\nScipy를 설치하기 위해, scipy 공식 홈페이지 www.scipy.\norg 를 방문한다. 사이트의 오른쪽에 'Download'가 보일\n것이다. 'Download' 를 클릭한다.\nSciPy.org ENTHOUGHT\nAbout \"Scipy\"\nS Getting\nInstall\nStarted\nInstall Getting Started Documentation Report Bugs Blogs Documentation\nBug Report\nSciPy (pronounced \"Sigh Pie\") is a Python-based ecosystem\nTopical\nof open-source software for mathematics, science, and\nSoftware\nengineering, In particular, these are some of the core\nCookbook �\npackages:\nSciPy Central\nNumPy SciPy library\nWiki �\nBase N-dimensional Fundamental\narray package library for scientific Scipy\ncomputing Conferences ☞\nBlogs �\nMatplotlib IPython NumFOCUS �\nIP[y]:\nComprehensive 2D Enhanced\nIPython NUMPY &\nPlotting Interactive Console\nSCIPY (LIBRARY):\nSciPy (library)\nSympy pandas Numpy �\nSymbolic Data structures & Download\nmathematics analysis\nDocumentation\n�\nBuild\nMore information... instructions"
    },
    {
        "page": 8,
        "text": "'Download'를 클릭하면, 아래와 같은 곳으로 이동하는데\n여기서 다시 한번 다른 곳으로 이동해야 한다. 그런데, 이\n사이트를 자세히보면 Numpy를 다운 받을 수 있는 곳도\n함께 소개되고 있다. 나중에 여기서 Numpy까지 다운\n받도록 한다.\nSciPy.org EN THOUGHT\nSciPy.org SciPy library\nAbout \"Scipy\"\nObtaining NumPY & SciPY Install\nGetting\nOfficial Source and Binary Releases Started\nDocumentation\nFor each offical release of NumPy and SciPy, we provide\nsource code (tarball) as well as binary packages for several Bug Report\nmajor platforms. Binary packages for other platforms may Topical\nbe available from your operating system vendor. Software\nProject Available packages Download location Cookbook ☞\nNumPy Official source code (all platforms) SourceForge site for NumPy SciPy Central\nand binaries for Windows & Mac\nOSX\nWiki\nSciPy Official source code (all platforms) SourceForge site for SciPy\nScipy\nand binaries for Windows & Mac\nConferences\nOSX\n'SouceForge site for Scipy'를 클릭한다.\nHome\n Name Modified ◆\n scipy 2013-04-06\n Totals: 1 Item\nscipy'폴더\n를 클릭한다."
    },
    {
        "page": 9,
        "text": "Home / scipy\n Name ◆ Modified ◆\n ↑ Parent folder \n 0.12.0 2013-04-09\n 0.12.0rc1 2013-03-30\n 0.12.0b1 2013-02-16\n최상위 버젼인 '0.12.0' 을 클릭한다.\nscipy-0.12.0-win32-superpack-python3.1. 2013-04-07\n scipy-0.12.0-win32-superpack-python2.7. 2013-04-07\n scipy-0.12.0-win32-superpack-pythom2.b.. 2013-04-07\n앞에서 설치한 파이션 버젼과 동일한 패키지 즉,\nscipy-0110-win-82-superpack-python27.7.. '을 다운\n받도록 한다."
    },
    {
        "page": 10,
        "text": "1.3 Numpy 설치하기\nNumpy를 설치하기 위해, 앞에서 Scipy와 함께 Numpy도\n다운 받을 수 있도록 안내했던 사이트로 이동한다.\nSciPy.org ENTHOUGHT\nSciPy.org SciPy library\nAbout \"Scipy\"\nObtaining NumPY & SciPY Install\nGetting\nOfficial Source and Binary Releases Started\nDocumentation\nFor each official release of NumPy and SciPy, we provide\nsource code (tarball) as well as binary packages for several Bug Report\nmajor platforms. Binary packages for other platforms may Topical\nbe available from your operating system vendor. Software\nProject Available packages Download location Cookbook �\nNumPy Official source code (all platforms) SourceForge site for NumPy SciPy Central\nand binaries for Windows & Mac\nOSX\nWiki\nSciPy Official source code (all platforms) SourceForge site for SciPy\nScipy\nand binaries for Windows & Mac\nConferences\nOSX\nBuild instructions are available for Linux, Windows and Mac Blogs\nOSX. NumFOCUS\n여기서 'SourceForge site for Numpy 를 클릭하고\nnumpy 를 다운 받을 수 있는 곳으로 이동한다.\nHome\nName Modified · Size\nNumPY 2013-04-07\nold Numarray 2006-08-24\nOld Numeric 2005-11-13\nTotals: 3 Items"
    },
    {
        "page": 11,
        "text": "Home / NumPY\n Name · Modified ·\n ↑ Parent folder \n 1.7.1 2013-04-25\n 1.7.1rc1 2013-03-24\n 1.7.0 2013-02-11\n현재 나온 것 중 최신 버젼인 '1.7.1'을 다운 받도록 한다.\nnumpy-1.7.1-win32-superpack-python2.6.. 2013-04-07\n numpy-1.7.1-win32-superpack-pythom2. 7... 2013-04-07\n numpy-1.7.f-win92-superpack-pythom3.1... 2013-04-07\nNumpy 도 32bit 으로 설치하되 파이션 버젼을 잘 확인하고\n다운 받아 설치하도록 한다."
    },
    {
        "page": 12,
        "text": "1.4 Matplotlib 설치하기\nMatplotlib는 plot에 대한 여러 함수를 내장하고 있는\n파이션 라이브러리이다. matplotlib를 설치하기 위해,\nmatplotlib 공식 홈페이지 matplotlib.org 를 방문한다.\n사이트에서 아래 쪽으로 좀 내려가다보면 'Download'를\n발견할 수 있을 것이다. 'Download'를 클릭한다.\nmatplotlib Fork FTM\nCithlub\nhone I downloads T seasch I examples I gallery I citation decs modules\nJohn Hunter (1968-2012) Quiry search\nGO\nOn August 28 2012. John D. Hunter. the creator of\nmatplotlib. died from complications arising from cancer\nEnter search terms module, class\ntreatment. after . brief but intense bettle with this\n01 fanction nene.\nterrible illness. John is survived by his wife Mirian. his\nthree daughters Fahel. Ava and Clara. his sisters Layne and\nMaiy. and his mather Sarah.\n1F you have benefited from John's many contribution.\nplease say thanks in the way that would matter most to\nhim. Please consider making 리 donation to the John Hunter\nttenorial.Fund.\nIntroduction\nmatplotiib is . python 2D plotting library whith produces\npublication quality figures in a variety of hardcopy formats\nand interactive environments across platforms. natplotlib\ncan be used in python scripts. the python and ipythen shell\n(ala MATLAB�! or Mathematica ⑩1), web application\nservers. and six graphical user interface toolkits.\nmatplotlib tries ta nake easy things easy and hard things\npossible. You can generate plots. histogrants. power\nspectra. bar charts. errorcharts. scatterplots. etc. with\njust 8 few lines of code. For . sampling. see the\nscreenshots. thambnail gallery. and examples directory\nFor example. using  ipython --pylab\" to provide an\ninteractive environment. to generate 10,000 gaussian\nrandon numbers and plot . histagran with 100 bins. you\nSimply need to type\nX 원 randn(10000)\nhist(x, 100)\nFor the power USEY, you have full contral of line styles.\nfont properties. axes properties. etc. Vie an object oriented\ninterface or via a set of functions familiar to MATLAB\nusers.\nDownload\nVisit the natplotio downloads page.\nDocumentation"
    },
    {
        "page": 13,
        "text": "다운로드 사이트에서 파이션 버젼이 2.7 이면서 32bit 용인\n패키지를 다운 받아 설치하도록 한다.\n1.2.1 - Latest stable version\n· matplotiti6-12.1-py2.7-thon.org-maces10.3.dmg\n· metplottifu-12.1-pv2.f-pythem.ors-macos10.klows\n· matplotlib-1.2.1.tar.gz\n· matplotlib-1.2.1.win-amd64-py2.6.exe\n· matplotlib-1.2.1.win-and64-py1.7.exe\n· matplotlib-1.2.1.win-amd64-py3.2.exe\n· matplotlib-1.2.1.win-amd64-py3.3.exe\n· matplotlib-1.2.1.win32-py2.6.exe\n· matplotlib-1.2.1.win32-py2.7.exe\n· matplotlib-1.2.1.win32-py3.2.exe\n· matplotlib-1.2.1.win32-py3.3.exe\n여기서는 'matplotlib-1.2.1.win32-py2.7.exe' 를 다운\n받아 기본 설정으로 설치한다. 최근에 matplotlib-1.3.0\n버젼을 설치해 봤는데 동작하지 않았다. 그러니 1.2.1버젼을\n설치하기 바란다."
    },
    {
        "page": 14,
        "text": "2. Python 으로 IIR 필터 설계하기\n이제 python 프로그래밍을 할 수 있는 환경이 갖추어졌다.\n지금부터 본격적으로 python 으로 디지털 필터를 설계해\n보도록 하자. 이 장에서는 먼저 IIR (Infinite Impulse\nResponse) 디지털 필터를 설계하는 방법을 소개할 것이다."
    },
    {
        "page": 15,
        "text": "2.1 IIR 필터의 정의\nIIR 은 Infinite Impulse Response 의 첫 자에서 나온\n용어로 필터의 응답상태를 나타내는 말이다. 말 그대로\nIIR필터에 임펄스(Impulse) 신호를 입력시키면 필터는 무한\n개의 데이터를 출력시킨다. 이것은 IIR 필터가\n재귀성(feedback) 구조를 가지기 때문에 이런 현상이\n나타나는데, 이 때문에 FIR 필터와는 다르게 임펄스를\n입력해도 IIR 필터의 구조를 파악할 수가 없다."
    },
    {
        "page": 16,
        "text": "2.2 사양(Specification) 정하기\n설계하기에 앞서, 우리는 필터의 사양을 정해 둘 필요가\n있다. 필터의 사양을 정하기 위해서는 몇 가지 고려해야 할\n사항들이 있는데 첫째는 cut-off frequency 이다. 이것은\n어느 한 지점의 주파수를 가리키는데 이 주파수를 기준으로\n통과되는 신호들과 제거되는 신호들이 구분되어진다.\n두번째는 stop-band 의 감쇄율이다. 이것은 보통 dB단위로\n표현되는데, 신호의 감쇄정도를 나타내는 요소이다. 그리고\nstop-band는 입력신호의 range와 관련이 있는데, 10bit\nrange를 가지는 입력이 들어왔을 경우, 필터의 stop-\nband가 -40dB이면 stop-band에 속하는 신호들은\n-40dB(1/100)으로 줄어 들게 된다. 예를 들어 1023이라는\n값이 들어온 경우, 입력은 10.23 정도로 줄어 들어 출력\n된다. 원래 stop-band에 있는 신호는 0이 되는게 바람직\n한데 1000 을 초과한 값에 대해서는 완전하게 필터처리를\n하지 못하고 10정도가 남는다. 이 값은 결국 나중에 노이즈\n성분이 될 가능성이 높다.\n나머지 신호처리회로가 이 정도 노이즈를 처리할 수 있다면\n모르겠지만 이 정도도 무시할 수 없다면 감쇄율을 더 높여야\n한다. 그래서 -60dB(1/1000)로 감쇄시키면 노이즈 성분은\n10bit입력에 대해서 1이 되는데 이 정도면 어느 정도 만족할\n수 있는 수준이라고 할 수 있다. 하지만 -60dB로 필터의\n사양을 바꾸게 되면 하드웨어의 크기도 증가한다는 사실도\n간과해서는 안된다."
    },
    {
        "page": 17,
        "text": "앞에서 언급한 몇 가지 고려사항들을 기준으로 우리가\n앞으로 설계해야 할 필터의 사양을 다음과 같이 임의로 정해\n보았다.\n1. cut-off freq. : 1.2MHz\n2. stop-band : -40dB\n3. Input/Output Range : 10bit\n4. Filter Type : IIR Low-Pass Filter\n5. Operating Freq. : 27MHz\n6. tap number : 3"
    },
    {
        "page": 18,
        "text": "2.3 주파수 특성 그래프 이해하기\n필터 설계에 앞서 자주 보게 될 주파수 특성 그래프를\n간략히 알아보도록 하자. 아래 그림은 주파수 특성 그래프를\n나타낸 것이다. 첫번째 파형은 필터의 gain(이득) 특성을\n나타내고 있고 두번째 파형은 필터의 phase(위상) 특성을\n나타내고 있다. 그리고 마지막 파형은 필터의 group\ndelay(군 지연) 특성을 보이고 있는 것이다.\n10\n0\nMagnitude(dB)\n-10\n-20\n-30\n-40\n-50\n-60\n-70\n-80\n2 4 8 10 12 14\n100\nPhase(Degree)\n50\n0\n-50\n-100\n-150\n-200\n-250\n-300\n2 4 10 12 14\n10\nDelay(sec)\n8\n6\n4\nGroup\n2\n0\n2 4 8 10 12 14\nMHz"
    },
    {
        "page": 19,
        "text": "앞 페이지에서, 이득에 관한 파형을 보면 4MHz 부터\n봉우리가 몇 개 솟아 오른 그림을 볼 수 있는데 이들\n봉우리의 최대 값이 stop-band 의 감쇄율이다. 아래에\nstop-band 감쇄율 (attenuation)이 정확히 어디인지\n표시해 두었다.\nf\nstop-band\nattenuation\ndB"
    },
    {
        "page": 20,
        "text": "앞에서 본 '주파수 특성 그래프'의 특성을 갖는 필터에\n일정한 크기를 갖는 신호를 입력시켰다. 입력신호는\n0~6MHz 범위의 주파수 성분을 갖고 있다. 이런 신호를\n필터에 입력시키면 어떤 결과가 나올까? 아마도 stop-\nband의 감쇄 모양을 닮은 신호가 나올 것이다. 아래 그림은\n입력신호와 출력신호를 중첩해 놓은 그림이다. 파란색\n파형은 0~1023으로 일정한 크기를 갖는 사인파\n입력신호이고 빨간색 파형은 필터를 통과한 출력신호이다.\nfilter transient characteristic\n2.0\n1.5\n1.0\n0.5\n0.0\n-0.5\n-1.0\n-1.5\n-2.0\n2\nx=0.0178112 y=0.579268"
    },
    {
        "page": 21,
        "text": "2.4 Python으로 필터 설계하기\n아래 코드는 IIR 필터를 설계하기 위한 파이션 코드이다. 이\n코드는 필터를 설계하기 위한 아주 기본적인 코드인데\n앞으로 여기에 새로운 코드들을 추가하여 필터를 완성해\n나갈 것이다.\n/usr/bin/python\nfrom pylab import\nfrom numpy import log10, arange, pi, linspace\nfrom scipy import diff\nfrom scipy · signal import ★\n## FIR Filter Or IIR Filter\nntap = 3\nunits = 1e6\nop hz = 27 ★ units\nfc = 2 ★ units\nFc Freq fc  (0.5* op_hz)\nnum, den-iirfilter (N=ntap, Wn= [Fc Freq], rp-0.1, rs 40,\nbtype= lowpass ftype=' cheby1 analog=0, output-'ba')\nw, h=freqz num, den)\nmag=20* log10 (abs (h))\nphase=unwrap angle (h) ) *180/pi\ngrpdly--diff (unwrap angle (h)))/diff (W)\nfigure (1)\nsubplot (311)\ntitle ( frequency characteristic')\nplot (w/max (W) ★ (op_hz/2/units)  mag)\nylim(-80, 10)\nxlabel ( 'MHz')\nylabel (  Magnitude (dB) , )\ngrid (True)\nsubplot(312)\nplot (w/pi* (op_hz/2/units), phase)\nylabel ( Phase (Degree) )\nxlabel ( MHz )\ngrid (True)\nsubplot(313)\nplot (w[1:]/pi ★ (op_hz/2/units) grpdly)\nylim(-1,30)\nxlabel ( 'MHz \"\nylabel (\"Group Delay (sec) )\ngrid (True)\nshow O"
    },
    {
        "page": 22,
        "text": "앞에서 소개한 기본코드는 원하는 파일명.py 로 저장하여\n더블클릭하거나 AcroEdit 같은 편집 프로그램에 python을\n'사용자 도구'로 등록하여 실행시킬 수 있다.\nX\nFC AcroEdit  [제목없음1.TXT]\n파일(F) 편집(E) 찾기(S) 매크로(M) 프로젝트(P) 도구(T) 보기(V) 창(W) 도움말(H) - 쓴 ⑧\nK7 (2 、 환경 설정(E)\n제목없음1.TXT 盟 문장 뒤 공백 삭제(T)\n10 20 30 HIH 시작하는 공백을 탭으로(B)\n공백률 랩 문자로 변환(P) 80 99 100 110\n.... \n·· II  ·····\n랩 문자를 공백으로 변환(O)\n비급 행 합치기(!)\n강제 열 맞춤된 명을 새 명으로 변환(N)\n중복 행 자동 삭제(D)\n빈 줄 자동 삭제(M)\n정렬(S)\n월 브라우저로 보기(V)\n폴더 열기(X)\n8 블럭 채우기(F)\nM 블럭 합계(L)\n블럭 평균(A)\n사용자 도구 가져오기(1)\n사용자 도구 내보내기(R)\n사용자 도구 설정(C)\n사용자 도구(U)\n사용자 도구 옵션\n명령(C)\nX\n사용자 도구 설정\n메뉴 이름ⓛ python\npython 추가(A) C:WPython27wpython.exe\n명령(M)\n삭제(R) %NAME%\n인자(P)\n편집(E) %PATH%\n작업 디렉토리(W)\n위로(U) 단축키(S) 없음\n아래로(D)\n이동 명령(Ⓡ\n정규 표현식(X)\n부표현식 번호(파일)\n부표현식 번호(행)\n닫기(C) 부표현식 번호(열)\n옵션(O)\n도스 화면 캡쳐 출력 윈도 내용 비우기\n최소화해서 실행 하기 실행이 종료될 때까지 대기\n인자 물어 보기 DOS 형식 파일명(8.3)\n자 도구 실행 결과 및 검색 결과 새 출력 펍 실행 종료 코드 표시\n출력 1 검색결과 1\n실행하기 전에 열려 있는 파일 모두 저장\n실행하기 전에 활성화된 파일 저장\n실행 후에 활성화된 파일 다시 읽기\n실행이 종료되면 비프음 출력\n확인 취소\n1 OD 1 햄 CAPS 삽입 영"
    },
    {
        "page": 23,
        "text": "일단 먼저 방향성을 살펴보기 위해 IIR 필터의 사양을\nntap=3, cut-off freq.=2MHz 로 설정하여 보았다.\n## FIR Filter Or IIR Filter\n #####\nntap = 3\nunits = 1e6\nop hz = 27 ★ units\nfc = 2 ★ units\nFc_ Freq = fc / (0.5*op_hz)\nnum, den-iirfilter N=ntap, Wn= Fc Freq] , rp=0.1, rs 40,\nbtype= lowpass , ftype⌀ chebyl analog=0, output='ba'\niirfilter()는 scipy라는 패키지에서 제공하는 함수이다. N은\n필터의 차수를 가리킨다. rp는 passband에서의 ripple 을\n최대 어느정도로 허용할 것인지를 묻는 인자이고 ftype은\n설계하려는 filter의 종류를 말한다.\niirfilter 가 어떤 알고리즘을 가졌는지 설계하는 입장에서는\n그다지 중요하지가 않다. 또한 이 함수에 입력해 주는\n필터타입도 그다지 중요하지 않다. 다만 iirfilter라는 함수가\n이들 정보를 원하기 때문에 입력해 줄 뿐이고 우리는 그\n결과로 계수들만 알아내면 된다. 일단 계수를 알아내면 어떤\n구조의 필터에 적용해도 괜찮다. 똑같은 동작을 하기 때문에\n어느 구조에 사용해도 무방하다. 다만 효율성의 차이만 있을\n뿐이다. 하드웨어 사이즈라든지 응답속도라는지...\nWn은 normalize 된 값인데 0~1 사이값을 갖는다. 필터를\n동작시키는 클럭의 주파수가 27MHz이면 그의 반인\n13.5MHz 가 1이 되고 0~13.5MHz사이에서 cut-off주파"
    },
    {
        "page": 24,
        "text": "수의 비가 어느 정도 되는지 판단하면 된다. 그리고 인수중\nrs라는 것이 있는데 이것은 stop-band의 감쇄율을\n나타낸다. iirfilter 의 나머지 인수는 개별적으로 찾아보길\n바란다.\n다음은 파이션코드의 아랫부분인데, gain 과 phase, 그리고\ngroup delay 를 구하기 위한 함수와 수식이 있고 또 그것을\n파형으로 보기 위한 부분이 나타나 있다.\nw⌀h freqz (num, den)\nmag=20* log10 (abs (h) )\nphase=unwrap (angle (h) ) *180/pi\ngrpdly=-diff (unwrap (angle (h) diff (W)\nfigure (1)\nsubplot (311)\ntitle ( , frequency characteristic')\nplot (w/max (W) ★ (op_hz/2/units) , mag)\nylim (-80,10)\nxlabel ( 'MHz')\nylabel ( Magnitude (dB) . )\ngrid (True)\nsubplot (312)\nplot (w/pi (op hz/2/units), phase)\nylabel (  Phase (Degree) \")\nxlabel ( MHz )\ngrid (True)\nsubplot (313)\nplot (w[1:]/pi  (op_hz/2/units) , grpdly)\nylim (-1,30)\nxlabel ( 'MHz')\nylabel ( Group Delay (sec) . )\ngrid (True)\nshow ("
    },
    {
        "page": 25,
        "text": "앞에서 소개한 IIR필터의 파이션 기본코드이다. 이것을\n실행시키도록 한다. (c://python.exe iir _filter.py)\n1 #! /usr/bin/python\n2\n3 from pylab import *\n4 from numpy import log10, arange, pi, linspace\n5 from scipy import diff\n6 from scipy signal import *\n7\n8\n9 #\n10 ## FIR Filter Or IIR Filter\n11\n12 ntap = 3\n13 units = 1e6\n14 op_hz = 27 * units\n15 fc = 2 * units\n16\n17\n18 Fc_Freq = fc / (0.5 op_hz)\n19\n20 num,den-iirfilter(N-ntap, Wn=[Fc_Freq], rp=0.1, rs 40,\n21 btype='lowpass 3 ftype='cheby1' , analog ⌀, output='ba')\n22\n23\n24 W, h=freqz(num, den)\n25 mag=20* log10 (abs(h))\n26 phase-unwrap(angle(h))*180/pi\n27 grpdly-diff(unwrap(angle(h)))/diff(w)\n28\n29 figure(1)\n30 subplot(311)\n31 title( frequency characteristic')\n32 plot(w/max(w)*(op_hz/2/units), mag)\n33 ylim(-80,10)\n34 xlabel ( 'MHz')\n35 ylabel ('Magnitude(dB) , )\n36 grid(True)\n37 subplot(312)\n38 plot(w/pi*(op_hz/2/units), phase)\n39 ylabel ( Phase(Degree)')\n40 xlabel ('MHz \")\n41 grid(True)\n42 subplot(313)\n43 plot(w[1:]/pi* (op_hz/2/units), grpdly)\n44 ylim(-1,30)\n45 xlabel ( MHz')\n46 ylabel ('Group Delay(sec)')\n47 grid(True)\n48\n49 show()"
    },
    {
        "page": 26,
        "text": "파이션 기본 코드를 실행시킨 결과가 아래에 나와 있다.\ncut-off freq. 로 2MHz를 입력했는데 3MHz가 나왔다.\n이처럼 iirfilter 에 원하는 값을 넣는다고 원하는 필터가\n나오는 경우는 아주 드물다. 하지만 근접하는 모습에서\nWn값을 조금 낮춰주면 되겠다라는 방향성을 생각해 볼 수\n있다.\nfrequency characteristic\n10\n0\nMagnitude(dB)\n-10\n-20\n-30\n-40\n-50\n-60\n-70\n-80\n2 10 12 14\n0\nPhase(Degree)\n-50\n-100\n-150\n-200\n-250\n-300\n2 6 8 10 12 14\n30\nDelay(sec)\n25\n20\n15\n10\nGroup\n5\n2 4 8 10 12 14\nMHz\nE\n그래서, iirfilter() 함수에서 N값을 변경하고 추가로 함수에\n있는 인수 중 ftype을 'bessel' 로, 'rs' 인수의 값을 40에서\n60으로 변경시킨다."
    },
    {
        "page": 27,
        "text": "N과 ftype, rs 인수 값을 변경한 전체 스크립트이다.\n1 #! /usr/bin/python\n2\n3 from pylab import *\n4 from numpy import log10, arange, pi, linspace\n5 from scipy import diff\n6 from scipy signal import *\n7\n8\n9\n10 ## FIR Filter Or IIR Filter\n11\n12 ntap = 3\n13 units = 1e6\n14 op_hz = 27 * units\n15 fc = 1.2 * units\n16\n17\n18 Fc_Freq = fc / (0.5*op_hz)\n19\n20 num,den-iirfilter(N-ntap, Wn=[Fc_Freq], rp=0.1, rs=60\n21 btype='lowpass 3 ftype='bessel ' , analog ⌀, output='ba')\n22\n23\n24 w,h=freqz(num,den)\n25 mag=20* log10 (abs(h))\n26 phase=unwrap(angle(h))*180/pi\n27 grodly=-diff(unwrap(angle(h))/diff(w)\n28\n29 figure(1)\n30 subplot(311)\n31 title( frequency characteristic')\n32 plot(w/max(w)*(op_hz/2/units), mag)\n33 ylim(-80,10)\n34 xlabel( MHz')\n35 ylabel( 'Magnitude(dB)')\n36 grid(True)\n37 subplot(312)\n38 plot(w/pi* (op_hz/2/units), phase)\n39 ylabel( Phase(Degree)')\n40 xlabel( 'MHz' )\n41 grid(True)\n42 subplot(313)\n43 plot(w[1:]/pi* (op_hz/2/units), grpdly)\n44 ylim(-1,30)\n45 xlabel( 'MHz')\n46 ylabel('Group Delay(sec)')\n47 grid(True)\n48\n49 show()\n50"
    },
    {
        "page": 28,
        "text": "스크립트를 실행시키면, 다음과 같은 주파수 특성을 얻을 수\n있다. 대략 cut-off freq. 가 1.2MHz 되는 것 같다.\nfrequency characteristic\n10\n0\nMagnitude(dB)\n-10\n-20\n-30\n-40\n-50\n-60\n-70\n-80\n2 8 10 12 14\nPhase(Degree)\n-50\n-100\n-150\n-200\n-250\n-300\n2 6 8 10 12 14\n30\nDelay(sec)\n25\n20\n15\n10\nGroup 5\n2 4 8 10 12 14\nMHz\niirfilter() 함수의 인수를 변경하고 그 값이 원하는 스펙에\n만족하는 값인지 확인하는 이런 일련의 과정은 만족하는\n값을 찾을 때까지 반복해야 하는 일들이다. 하지만 변하는\n값의 추이를 살펴보면 원하는 값을 금방 찾을 수 있다.\n이것에 대해서는 필터를 손으로 설계하지 않고 프로그램으로\n좀 편하게 설계하는 것에 대한 대가라고 생각하는 게 좋다고\n본다."
    },
    {
        "page": 29,
        "text": "필터의 계수(coefficient) 를 구하기 위해 print 문을\n추가하였다.\n1 #! /usr/bin/python\n2\n3 from pylab import *\n4 from numpy import log10, arange, pi, linspace\n5 from scipy import diff\n6 from scipy.signal import *\n7\n8\n9\n10 ## FIR Filter Or IIR Filter\n11\n12 ntap = 3\n13 units = 1e6\n14 op_hz = 27 * units\n15 fc = 1.2 * units\n16\n17\n18 Fc_Freq = fc / (0.5*op_hz)\n19\n20 num,den=iirfilter(N=ntap, Wn=[Fc_Freq], rp 0.1  rs 60,\n21 btype=`lowpass 3 ftype= bessel · analog ⌀, output='ba' )\n22\n23 print \"num=%s\\nden=%s\\n\"%(num, den)\n24\n25\n26 W, h=freqz(num,den)\n27 mag=20* log10 (abs (h))\n28 phase-unwrap(angle(h))*180/pi\n29 grodly-diff(unwrap(angle(h)))/diff(w)\n30\n31 figure(1)\n32 subplot(311)\n33 title( frequency characteristic')\n34 plot(w/max(w)*(op_hz/2/units), mag)\n35 ylim(-80,10)\n36 xlabel ( MHz\n37 ylabel ('Magnitude(dB)')\n38 grid(True)\n39 subplot(312)\n40 plot (w/pi* (op_hz/2/units), phase)\n41 ylabel ('Phase(Degree)')\n42 xlabel ('MHz )\n43 grid(True)\n44 subplot(313)\n45 plot(w[1:]/pi (op_hz/2/units), grpdly)\n46 ylim(-1,30)\n47 xlabel( 'MHz')\n48 ylabel('Group Delay(sec) )\n49 grid(True)\n50\n51 show()"
    },
    {
        "page": 30,
        "text": "print 문에서 %s 는 문자열을 입력받는 인수이다. print\n문의 \" \"안에는 %s가 두 개있다. 이것들은 각각 num 과 den\n의 내용을 입력 받게 된다. 그리고 '\\n'은 줄 바꾸기이다.\n21 btype= Towpass J ftype= bessel ana1og=0\n22\n23 print \"num=%s\\nden=%s\\n\"%(num, den)\n24\n25\n필터의 계수가 다음과 같이 나왔다.\n6\n7 num=[ 0. 00199218 0.00597655 0. 00597655 0.00199218]\n8 den=[ 1. -2. 35744435 1  87863043 -⌀. 5052486 ]\n필터의 계수는 입력신호와 곱해지기 때문에, 필터의 계수는\n2의 power승으로 표현될 수 있어야 한다. 하지만 위의\n계수들은 2의 power승으로 표현할 수 없는 숫자들이다.\n2의 power승으로 표현 가능한 숫자는 끝 숫자가 0 이나 5\n로 끝나는 것들이다."
    },
    {
        "page": 31,
        "text": "2.5 계수에 대해 양자화하기\n파이션 스크립트 윗부분은 파이션 라이브러리를 부르는\n부분이다. 여기에 mathwang 이라는 라이브러리를 추가할\n것이다. 이 라이브러리에는 quen_coeff_auto_iir() 라는\n함수가 있는데, quen_coeff_auto_iir() 함수는 계수들을\n자동으로 2의 power승으로 양자화 시켜준다. mathwang\n라이브러리는 Appendix A 에 수록되어 있으니 참고하길\n바란다. quen_coeff_auto_iir() 에 의해 양자화된 계수를\n다시 추출하기 위해 다시 한번 print 문을 사용하였다."
    },
    {
        "page": 32,
        "text": "1 #! /usr/bin/python\n2\n3 from pylab import *\n4 from numpy import log10, arange, pi, linspace\n5 from scipy import diff\n6 from scipy signal import *\n7 from mathwang import *\n8\n9\n10 ## FIR Filter Or IIR Filter\n11\n12 ntap = 3\n13 units = 1e6\n14 op_hz = 27 * units\n15 fc = 1.2 * units\n16\n17\n18 Fc_Freq = fc / (0.5*op_hz)\n19\n20 num,den-iirfilter(N=ntap, Wn=[Fc_Freq], rp=0.1, rs 60,\n21 btype='lowpass ftype= bessel , analog ⌀, output='ba')\n22\n23 num,den-quen_coeff_auto_iir(nun,den,9)\n24 print \"run-listnden=8strsum(num)/sum(des)=Ns15um, den, sum(num)/ sum( den))\n25\n26\n27 w,h-freqz(num,den)\n28 mag=20* log10 (abs(h))\n29 phase=unwrap(angle(h))*180/pi\n30 grpdly-diff(unwrap(angle(h)))/diff(w)\n31\n32 figure(1)\n33 subplot(311)\n34 title( frequency characteristic')\n35 plot (w/max(w)*(op_hz/2/units), mag)\n36 ylim(-80,10)\n37 xlabel( 'MHz\n38 ylabel( 'Magnitude(dB) . )\n39 grid(True)\n40 subplot(312)\n41 plot(w/pi*(op_hz/2/units), phase)\n42 ylabel( Phase(Degree)')\n43 xlabel('MHz )\n44 grid(True)\n45 subplot(313)\n46 plot(w[1:]/pi* (op_hz/2/units), grpdly)\n47 ylim(-1,30)\n48 xlabel('MHz')\n49 ylabel('Group Delay(sec) )\n50 grid(True)\n51\n52 show ()\n53"
    },
    {
        "page": 33,
        "text": "양자화를 하기 위해서 quen_coeff_auto_ iir()에 필터의\n계수인 num과 den을 넣어준다. num의 계수의 합을 den의\n계수의 합으로 나눈 값도 표시하도록 하였다. 이 값이 1일때\nDC(freq.=0Hz) 값이 0dB 또는 x1 이 된다.\n22\n23 num, den=quen_coeff_auto_iir(num, den,9)\n24 print \"nun-Hsindenvers/nsum(rum)/sun(den)oN=Na/30/mun, den, sum(num)/sum(den) )\n25\n26\n위의 그림이 작아서 잘 안보일 것 같아 좀 확대하였다. %\n앞에서 줄바꿈하고 탭키를 두 번정도 누른 것이다.\nZ Z\n23 num,den-quen_coeff_auto_iir(num, den, 9)\n24 print \"num=%sInden=%s\\nsum(num)/sun(den)=%s\"\n25 %(num, den」 sum (num)/sum(den))\n26\n계수의 끝이 0이나 5로 변경되었고 num/ den 의 값이 1이\n되었다.\n1 num=[0.001953125, 0.005859375, 0.005859375, 0.001953125]\n2 den=[1, -2.357421875, 1.876953125, -0.50390625]\n3 sum(num)/sum(den)=1.0"
    },
    {
        "page": 34,
        "text": "양자화된 계수를 적용하여 파이션 스크립트를 실행시키면\n다음과 같은 필터의 특성을 구할 수 있다.\nfrequency characteristic\n10\n0\nMagnitude(dB)\n-10\n-20\n-30\n-40\n-50\n-60\n-70\n-80\n2 4 8 10 12 14\n0\nPhase(Degree)\n-50\n-100\n-150\n-200\n-250\n-300\n2 4 6 8 10 12 14\n30\nDelay(sec)\n25\n20\n15\n10\nGroup\n5\n0\n2 4 8 10 12 14\nMHz\n문"
    },
    {
        "page": 35,
        "text": "양자화 전후의 주파수 특성을 겹쳐서 비교해 보도록 하자.\n1 #! /usr/bin/python\n2\n3 from pylab import *\n4 from numpy import log10, arange, pi, linspace\n5 from scipy import diff\n6 from scipy.signal import *\n7 from mathwang import *\n8\n9\n10 ## FIR Filter Or IIR Filter\n11\n12 ntap ■ 3\n13 units = 1e6\n14 op_hz = 27 * units\n15 fc = 1.2 * units\n16\n17\n18 Fc_Freq = fc / (0.5 op_hz)\n19\n20 num,den-iirfilter(N=ntap, Wn=[Fc_Freq], rp 0.1 rs=60,\n21 btype='lowpass ftype= bessel analog ⌀, output='ba')\n22\n23 num2,den2-quen_coeff_auto fir(num,den,9)\n24\n25\n26 W h-freqz(num,den)\n27 mag=20* log10 (abs (h))\n28 phase-unwrap(angle(h))*180/pi\n29\n30 w2,h2=freqz(num2,den2)\n31 mag2=20* log10 (abs(h2))\n32 phase2-unwrap(angle(h2))*188/pi\n33\n34\n35 figure(1)\n36 subplot(211)\n37 title('frequency characteristic')\n38 hold (True)\n39 plot (w/max(w)*(op_hz/2/units), mag)\n40 hold (True)\n41 plot (w2/max(w2)*(op_hz/2/units), mag2, --r\")\n42 ylim(-80,10)\n43 xlabel ( MHz\n44 ylabel('Magnitude(dB)')\n45 grid(True)\n46\n47 subplot(212)\n48 hold(True)\n49 plot (w/pi * (op_hz/2/units), phase)\n50 hold (True)\n51 plot (w2/pi * (op_hz/2/units), phase2,\n52 ylabel Phase (Degree)')\n53 xlabel('MHz')\n54 grid(True)\n55\n56 show()"
    },
    {
        "page": 36,
        "text": "frequency characteristic\n10\n0\n-10\nMagnitude(dB)\n-20\n-30\n-40\n-50\n-60\n-70\n-80\n2 4 8 10 12 14\nMHz\n-50\nPhase(Degree)\n-100\n-150\n-200\n-250\n-300\n2 4 8 10 12 14\nMHz\n위 그림은 파란색 선과 빨간색 선이 겹쳐져 있다. 파란색\n선은 양자화 되기 전의 특성을 나타낸 것이고 빨간색 선은\n양자화 된 필터의 특성을 나타낸 것이다. 그림에서 알 수\n있듯이 양자화 전과 후가 거의 동일하다. 그렇다고 양자화를\n하지 않아도 되는것은 아니다. 하드웨어로 설계하기\n위해서는 2의 power승으로 변환을 꼭 해야만 한다.\n양자화된 계수를 구하는 것이 중요한 것이다."
    },
    {
        "page": 37,
        "text": "아래 코드를 보면 iir()이라는 함수가 추가되었다.\n7 from mathwang import\n8\n9\n10 def iir (din):\n11 den_sum=[]\n12 dout= 0,0,0]\n13 for i in xrange(len(din)):\n14 if i>2:\n15 mu10 = 0.001953125 * (din[i] + din[i-3])\n16 mull = 0. 005859375 + (din[i-1] + din[i-2])\n17 den_sum mu10 + mull\n18\n19 bmu10 - - (-2.357421875) * dout[i-1]\n20 bmul1 - - ( 1.876953125) * dout[i-2]\n21 bmu12 = - (-0.50390625) * dout[i-3]\n22 num_sum = bmu10 + bmul1 + bmu12\n23\n24 pre_dout = den_sum + num_sum\n25 dout.append(pre_dout)\n26 return dout\n27\n28 ####\n29 ## FIR Filter Or IIR Filter\n30 ##\n31 ntap = 3\n32 units = 1e6\n33 op_ hz = 27 units\n34 fc = 1.2 units\n35\n36\n37 Fc_Freq - fc / (0.5*op_hz)\n38\n39 num,den-iirfilter(N-ntap, Wn-[Fc_Freq], rp=0.1 rs 60,\n40 btype=`lowpass ftype='bessel . analog=⌀, output='ba')\n41\n42 num,den·quen_coeff_auto_iir(num,den,9)\n43\n44\n45 W, h=freqz(num,den)\n46 mag=20* log10 (abs(h))\n47 phase-unwrap(angle(h))*188/pi\n48 grodly-diff(unwrap(angle(h)))/diff(w)\n49\n50\n51 t=arange(1024)*(37e-9)\n52 chirp_sig 511⌀chirp(t, f0 0, t1=1023*(37e-9), f1=6e+6, method='linear' phi-0)+512\n53\n54 dout iir(chirp_sig)\n55\n56 figure(2)\n57 title('python iir simulation')\n58 hold(True)\n59 plot (chirp_sig)\n60 hold (True)\n61 plot(dout 'r')\n62 ylim([-2,1026])\n63 grid(True)\n64\n65 show()"
    },
    {
        "page": 38,
        "text": "9\n10 def iir (din):\n11 den_sum=[]\n12 dout= [0,0,0]\n13 for i in xrange(len(din)):\n14 if i>2:\n15 mu10 = 0.001953125 * (din[i] + din[i-3])\n16 mul1 = 0 005859375 * (din[i-1] + din[i-2])\n17 den_sum = mu10 + mul1\n18\n19 bmu10 = (-2.357421875 * dout[i-1]\n20 bmul1 = - 1.876953125 * dout[i-2]\n21 bmu12 = - (-0.50390625) * dout[i-3]\n22 num_sum = bmu10 + bmul1 + bmu12\n23\n24 pre_dout = den_sum + num_sum\n25 dout.append(pre_dout)\n26 return dout\n27\niir()함수는 2의 power승으로 구한 계수를 하드웨어와\n유사하게 소프트웨어로 필터를 구현한 것이다.\ndin[9:0] dout[9:0]\nbo +\nD 0\nb1 -a0\nD D\nb2 + -a1\nD D\nb3 -a2\nIIR 필터의 구조는\n옆의 그림과 같은데\nnum은 b0~b3으로\n적용되고 den은 a0\n~a2로 적용된다."
    },
    {
        "page": 39,
        "text": "python iir simulation\n1000\n800\n600\n400\n200\n200 400 600 800 1000 1200\nE\n다음은 iir() 함수에 0~6 MHz의 주파수 성분을 갖는\n신호(파란색)를 넣고 필터의 결과를 본 것이다(빨간색)."
    },
    {
        "page": 40,
        "text": "앞에서는 우리가 여지껏 구했던 계수로 하드웨어 구조와\n유사하게 소프트웨어로 iir() 함수를 만들고 시뮬레이션을 한\n것을 보였다. 하지만 scipy 패키지에는 lfilter 라는 함수가\n있어 계수값만 입력시키면 그 계수에 맞는 필터를 쉽게 만들\n수 있다.\nt=arange (1024) ★ (37e-9)\nchirp_sig - 511 chirp(t, fo ⌀, t1-1023* (37e-9), f1-6e+6, method-'linear' phi-0) +512\nfn open  chirp_ 10bit. t.xt w )\nfor val in chirp_sig:\nfn. write ('총3x\\n'총val)\nfn.close\nfilter in=[]\nfn open ( chirp_10bit. txt 'r')\nfor val in fn. readlines () :\nfilter in  append (int (val, 16))\nfn.close 0\nfilter out lfilter (num, den, filter_in)\nfigure (2)\ntitle ( filter transient response')\nhold (True)\nplot (t*6/ (1023*(37e-9)), filter in)\nhold (True)\nplot (t*6/(1023*(37e-9)),filter_out, 'ri')\nylim([-2,1023])\ngrid (True)"
    },
    {
        "page": 41,
        "text": "filter transient response\n2.0\n1.5\n1.0\n0.5\n0.0\n-0.5\n-1.0\n-1.5\n-2.0\n3\n+ F\nlfilter 를 이용해서 만든 iir 필터의 입력과 출력을 겹쳐 놓은\n그림이다. 파란색 파형은 0~6MHz의 입력신호이고 빨간색\n파형은 필터를 통과한 출력신호이다. 1.2MHz의 cut-off\nfrequency 를 갖는 필터이므로 1.2MHz에서 -3dB(0.707)\n가 되는 것을 확인할 수 있다."
    },
    {
        "page": 42,
        "text": "파이션 패키지 중 scipy에 있는 chirp()함수를 사용하면\n0~6MHz의 주파수를 가지는 신호를 파일로 덤프 받을 수\n있다. 나중에 이렇게 덤프 받은 파일은 verilog로 설계한\n필터에 입력으로 사용할 수 있다.\nfn open (  chirp 10bit. txt W)\nfor val in chirp sig:\nfn. write ( 3x\\n , val)\nfn. close O"
    },
    {
        "page": 43,
        "text": "데이터는 헥사(Hex) 포맷으로 저장하였다. 따라서 나중에\nverilog에서 읽어올 때에는 Hex포맷으로 읽어와야 한다.\n3ff\n 3fe\n 3fe\n 3fe\n 3fe\n 3fe\n 3fe\n 3fe\n 3fe\n 3fe\n 3fd\n 3fd\n 3fc\n 3fb\n 3fa\n 3f8\n 3f7\n 3f5\n 3f2\n 3ef\n 3ec\n 3e8\n 3e3\n 3de\n 3d8"
    },
    {
        "page": 44,
        "text": "1 #! /usr/bin/python\n2\n3 from pylab import *\n4 from numpy import log10, arange, pi, linspace\n5 from scipy import diff\n6 from scipy signal import *\n7 from mathwang import *\n8\n9 \n10 ## FIR Filter Or IIR Filter\n11 ===========\n12 ntap = 3\n13 units = 1e6\n14 op_hz = 27 * units\n15 fc = 1.2 * units\n16\n17\n18 Fc_Freq = fc / (0.5 op_hz)\n19\n20 num,den-iirfilter(N-ntap, Wn=[Fc_Freq], rp=0.1, rs 60,\n21 btype='lowpass ftype= 'bessel , analog ⌀, output='ba' )\n22\n23 num,den-quen_coeff_auto_iir(num,den,9)\n24 pow2_print(num, 9)\n25 pow2_print(den 9)\n26\n27\n28 w,h-freqz(num,den)\n29 mag=20* log10 (abs(h))\n30 phase=unwrap(angle(h))*180/pi\n31 grodly-diff(unwrap(angle(h)))/diff(w)\n32\n33 figure(1)\n34 subplot(311)\n35 title( frequency characteristic')\n36 plot(w/max(w)*(op_hz/2/units), mag)\n37 ylim(-80,10)\n38 xlabel('MHz\n39 ylabel( 'Magnitude(dB)' )\n40 grid(True)\n41 subplot(312)\n42 plot(w/pi*(op_hz/2/units), phase)\n43 ylabel( Phase(Degree)')\n44 xlabel( 'MHz' )\n45 grid(True)\n46 subplot(313)\n47 plot(w[1:]/pi* (op_hz/2/units), grpdly)\n48 ylim(-1,30)\n49 xlabel('MHz' )\n50 ylabel、Group Delay(sec) )\n51 grid(True)\n52\n53 show()\n54"
    },
    {
        "page": 45,
        "text": "앞페이지에 보인 파이션 스크립트에는 pow2_print()라는\n함수가 추가되어 있다. 이 함수는 계수를 구성하고 있는 2의\npowet들을 보여주는 함수이다. 실행시키면 다음과 같은\n출력을 나타내 보인다.\n2\n3 0.001953125 - -> [-9]\n4 0.005859375 - -> [-8, -9]\n5 0.005859375 --> [-8, -9]\n6 0.001953125 - > [-9]\n7 1. [0]\n8 -2.357421875 - -> [1, -2, -4, -5, -7, -8, -9]\n9 1.876953125 - -> [⌀, -1, -2, -3, -9]\n10 -0.50390625 - - > [-1, - 8]\n11\n0.005859375 는 2^-8 과 2^-9 의 합으로 구성되어 있다는\n것을 나타내 보인 것이다.\n부록에 수록해 놓은 mathwang 라이브러리에는 다소\n버그가 있을 수 있는 참고만 하길 바란다."
    },
    {
        "page": 46,
        "text": "2.6 Group Delay 특성 보기\n아래 그림은 IIR 필터의 group delay를 나타낸 것인데,\ngroup delay 값이 일정하지 않는 것을 볼 수 있다. group\ndelay값이 일정하지 않으면 필터를 통과하는 신호들의\n딜레이가 틀리다는 말이므로 이 신호를 가지고서 신호처리를\n하면 곤란한 일이 발생할 수 있다.\n그래서 보통 IIR 필터는 신호를 검출하는 용도로 많이\n사용하고 신호처리를 하는 주요경로에서는 사용하지 않는\n편이다.\nfrequency characteristic\n10\n0\n-10\nMagnitude(dB)\n-20\n-30\n-40\n-50\n-60\n-70\n-80\n2 8 10 12 14\nMHz\n30\n25\nDelay(sec)\n20\n15\nGroup\n10\n5\n2 4 8 10 12 14\nMHz"
    },
    {
        "page": 47,
        "text": "3. Verilog 로 IIR 필터 설계하기\n지금까지 우리는 파이션으로 IIR 필터를 설계하였고 그\n결과로 필터의 계수 (coefficient) 들을 구하였다. 이제 이\n계수들을 가지고 verilog 로 IIR 필터를 설계하는 방법을\n배우도록 하겠다."
    },
    {
        "page": 48,
        "text": "3.1 IIR 필터의 하드웨어 구조\nIIR 디지털 필터는 아래 그림과 같은 구조를 가진다.\n'D'라는 문자를 가진 사각형 모양의 블록은 Flip-Flop을\n나타낸다. 그리고 삼각형 기호는 곱하기 기능을 나타내는\n것인데 여기에 필터의 계수들이 하나씩 사용된다.\ndin[9:0] dout[9:0]\nb0\nb1 -a0\nb2 -a1\nb3 -a2"
    },
    {
        "page": 49,
        "text": "b0~b3 계수는 보통 b0와 b3, b1과 b2가 같은 값을 가지기\n때문에 b0~b3으로 구성된 하드웨어를 약간 변형을 시켜\n하드웨어 크기를 축소시킬 수 있다. b0와 b3이 같기 때문에\nb0만 사용하고 b1과 b2가 같기 때문에 b1만 사용해서\n하드웨어를 줄일 수 있다. 대체로 곱셈이 들어가면\n하드웨어가 커지기 때문에 곱셈의 개수를 줄이고자 하는\n것이다.\ndin[9:0] dout[9:0]\nb0\nb1 -a0\n-a1\n▼\n-a2"
    },
    {
        "page": 50,
        "text": "3.2 Verilog 전체코드 분석하기\nverilog로 작성된 IIR필터의 전체코드를 세페이지에 걸쳐\n수록해 놓았다.\n1 module iir_lpf1p3m\n2 clk ,\n3 rstb\n4 din\n5 dout\n6 );\n7\n8 input clk;\n9 input rstb;\n10 input [9:0] din;\n11 output [9:0] dout;\n12\n13 u10.0\n14 reg [9:0] z2 z1, z0;\n15 always ● (posedge clk or negedge rstb) begin\n16 if (!rstb) z2 z1 z0} 介 {3{10'd0}] ;\n17 else z2 z1 z0} <= (z1 z0 din} ;\n18 end\n19\n20 num= [0.001953125, 0.005859375, 0.005859375, 0.001953125]\n21\n22 0.001953125 = 2^-9\n23 0.005859375 = 2^-8 + 2^-9\n24\n25 wire [10:0] sum0 = {1'do, din} + {1'do, z2} ;\n26 wire [10:0] sum1 = {1'do, z0} + {1'do, z1} ;\n27\n28 X 2^+9\n29 wire [10:0] mu10 = sum⌀;\n30\n31 X 2^+9\n32 wire [12:0] mull = {1'do, sum1 ,1'd0}\n33 + {2'do, sum1 } ;\n34\n35  X 2^+9\n36 wire [13:0] num_tot = {3'do, mu10}\n37 + {1'do, mul1} ;\n38"
    },
    {
        "page": 51,
        "text": "39\n40 wire [20:0] pre_dout;\n41 reg [20:0] bz2,bz1,bz0;\n42 always @(posedge clk or negedge rstb) begin\n43 if (!rstb) bz2,bz1,bz0) 介 {3{21'd0}};\n44 else bz2,bz1,bz0) 介 bz1,bz0,pre_dout) ;\n45 end\n46\n47\n48 den=[1, -2.357421875, 1.876953125, -0.50390625]\n49\n50 -2.357421875 = 2^+1 + 2^-2 + 2^-4 + 2^-5 + 2^-7 + 2^-8 + 2^-9\n51 1.876953125 = 2^+0 + 2^-1 + 2^-2 + 2^-3 + 2^-9\n52 -0.50390625 = 2^-1 + 2^-8\n53\n54 X 2^+9\n55 wire [31:0] bmu10 = {{ 1{bz0 [20]}}, bz0, 10'd0}\n56 + {{ 4 bz0 [20]}}, bz0,7'd0}\n57 + {{ 6 bz0 [20]}] bz0 5'd0}\n58 + {{ 7 bz0 [20]}] bz0 4'd0}\n59 + {{ 9  bz0 [20]}] bz0 2'd0}\n60 + {{10 bz0 [20]}},bz0, 1'd0}\n61 + {{11 {bz0 [20]}},bz0};\n62\n63 X 2^+9\n64 wire [30:0] bmul1 = {{ 1{bz1 [20]}],bz1,9'd0}\n65 + {{ 2 bz1 [20]}},bz1,8'd0}\n66 + { { 3 bz1 [20]}],bz1,7'd0}\n67 + {{ 4 bz1 [20]}],bz1,6'd0}\n68 + {{10 {bz1 [20]}],bz1];\n69\n70 // X 2^+9\n71 wire [29:0] bmu12 = {{1{bz2 [20]]],bz2,8'd0}\n72 + {{8{bz2 [20]}],bz2,1'd0] ;\n73\n74 // X 2^+9\n75 wire [33:0] den_tot = {2 {bmu10 [31]}}, bmul0}\n76 - {{3 {bmul1 [30]}}, bmul1}\n77 + {{4{bmu12 [29]]},bmu12]\n78"
    },
    {
        "page": 52,
        "text": "79\n80 wire [24:0] den_tot2 den_tot [33:9] ;\n81\n82 wire [25:0] num_ den_sum = {12:do num_ tot} + (den_tot2 [24]  den_tot2)\n83\n84 assign pre_dout = ( num_den_sum [25] ) ? 21'd0 :\n85 num_den_sun [24:21]) ? 21\"h1FFFFF : num_den_sun [20:0] ;\n86\n87 reg [9:0] dout;\n88 always �(posedge clk or negedge rstb) begin\n89 if (!rstb) dout <= 10'do;\n90 else dout <= ( pre_dout [20]) ? 10'do\n91 pre_dout [19]) ? 10'd1023 : pre_dout [18:9] ;\n92 end\n93\n94 endmodule"
    },
    {
        "page": 53,
        "text": "num 의 계수는 네개인데, 이것은 차례대로 각각 din 과 din\n을 한번 딜레이한것, 두번 딜레이한 것 그리고 세번 딜레이한\n것과 곱해져야 하는 계수들이다. 따라서, 계수들과 곱하기를\n하기 이전에 din 을 3번 딜레이시켜야 한다.\ndin[9:0]\n13 u10.0\n14 reg [9:0] z2 z1 z0;\n15 always (posedge clk or negedge rstb) begin\n16 if rstb) { z2 z1, z0} <= {3 [10'd0}] ;\n17 else (z2 z1 z0} <= (z1 z0  din} ;\n18 end\n10"
    },
    {
        "page": 54,
        "text": "num 의 계수는 4개인데, 첫번째와 네번째의 계수가 같고\n두번째와 세번째의 계수값이 서로 같다. 따라서, 하드웨어를\n줄이기 위해 같은 계수끼리 묶어서 계수를 한번만\n적용시키려고 한다. 즉, (a * c)+(b * c) = (a+b)*c 로 같은 c 를\n한번만 사용하겠다는 계획이다. a 와 b 는 din 또는 delay\n요소이다.\n+\n24\n25 wire [10:0] sum0 = (1'do din} + {1'do, z2] ;\n26 wire [10: o] sum1 = (1'do z0} + {1'd0 z1} ;\n27"
    },
    {
        "page": 55,
        "text": "다음은 계수를 곱해주는 부분이다. mul0 에는\n0.001953125(2^-9) 을 곱하고 mul1 에는\n0.005859375(2^-9 + 2^-8) 을 곱했는데 mul0 에 대해서\nsum0 가 그냥 대입된 것은 나중에 2^-9을 해 주겠으니\n지금은 그냥 이것이 2^-9 가 곱해진 것이라고 여겨라 라는\n무언의 약속을 한 것이라고 보면 된다.\n만약 sum0(1 1bit) 에 대해서 2^-9\n처리를 하게 된다면 sum0 는 2 bit\n밖에 안 남게 된다. 이렇게 연산해서\n하드웨어를 구성하면 신호가 다 잘려\n버려 신호의 해상도를 모두 잃게 되고\n말 것이다.\n신호의 해상도에 손실을 보지 않기\n위해서 din 의 신호 range 인 10bit\n을 그대로 유지시켰다는 점에 주목하고\n신호처리할 때에는 이점에 유의해야\n한다는 점을 꼭 명심하길 바란다.\n+ b0\nb1\n28 X 2^+9\n29 wire[10:0] mu10 sum0\n30\n31  X 2^+9\n32 wire[12:0] mul1 = {1'do, sum1 1'do}\n33 + {2'do sum1\n34\n35 X 2^+9\n36 wire[13:0] num tot = {3'do, mu10}\n37 + {1'do, mul1} ;\n38"
    },
    {
        "page": 56,
        "text": "다음은 den 계수단을 처리하는 위해 앞에서 해주었던\n것처럼 출력에 대해서 딜레이(delay)를 먼저 해 준다.\n그런데, verilog 코드를 잘 살펴보면 dout 로 출력되기전\n신호 range 가 21bit 되는 것을 발견할 수 있다. 이것은\n하드웨어 설계전에 짐작해야 하는 부분으로 다음과 같이\ndout[9:0]\n짐작하여 크기를 정한다. 첫째, din과\ndelay 에 계수가 곱해지므로 계수의\n최대크기가 몇 bit인지 알아본다. den\n에서 제일 큰 계수가 2.357421875\n이므로 이는 2bit(2'b11=3) 범위안에\n들어오는 숫자다. 따라서 이 계수와\n곱해지면 din은 2bit 이 증가한다. 둘째\n소수이하 9자리 연산이므로 9비트가 추\n가된다. 만약 최종출력이 부호가 있는\nsigned 신호라면 1bit이 추가 되겠지만\n여기서는 부호없는 unsigned 출력이므\n로 총 11bit이 늘어나는 효과를 보일\n것이다 라고 짐작할 수 있다.\nden= [1, -2.357421875, 1.876953125, -0.50390625]\n-2.357421875 = 2^+1 + 2^-2 + 2^-4 + 2^-5 + 2^-7\n1 876953125 24+0 + 24-1 L 24-2 + 2A-3 + 24-9\n39\n40 wire [20:0] pre_dout;\n41 reg [20:0] bz2 bz1 bz0;\n42 always (posedge clk or negedge rstb) begin\n43 if (!rstb) {bz2 bz1 bz0} {3 {21:d0}} ;\n44 else (bz2 bz1 bz0} <= bz1 bz0  pre_dout};\n45 end\n46"
    },
    {
        "page": 57,
        "text": "den 의 계수들도 dout 에서 한번 딜레이된 것, 두번 딜레이\n된 것, 세번 딜레이된 것들과 차례로 곱하도록 되어 있는데,\n아래는 이들 계수들이 어떤 방식으로 곱해졌는지를 보여주고\n있다. 여기서도 앞에서와 마찬가지로 해상도를 고려해\n나중에 2^-9을 해주기로 하고 연산하였다.\n54 X 2^+9\n55 wire [31:0] bmu10 = { { 1 (bz0 [20] }} bz0, 10'd0}\n56 + { { 4 {bz0 [20] } } bz0 7'd0}\n57 + { { 6 bz0 [20] } } bz0 5'd0}\n58 + {{ 7 bz0 [20] } } bz0 4 I do}\n59 + { { 9 bz0 [20] } } bz0 2  do}\n60 + { {10 {bz0 [20] } } bz0 1 . do}\n61 + { { 11 bz0 [20] }} bz0} ;\n62\n-a0\n63 X 2^+9\n64 wire [30:0] bmul1 = { { 1 {bz1 [20]}] bz1 9'd0}\n65 + { { 2  bz1 [20] } } bz1 8'd0}\n66 + { { 3 bz1 [20] } } bz1 7'd0}\n67 + { { 4 bz1 [20] } } bz1 6'd0}\n68 + { {10 bz1 [20] }} ,bz1} ,\n-a1 69\n70 X 2^+9\n71 wire [29:0] bmu12 = { {1 (bz2 [20]}] bz2 8'd0}\n72 + {{8{bz2 [20] }} bz2 1'd0} ;\n73\n74 X 2^+9\n75 wire [33:0] den_tot = { {2 {bmu10 [31]}] bmul0}\n-a2 76 - { { 3  bmul1 [30] } } bmul1}\n77 + { { 4 bmu12 [29] } } bmul2} ;\n78"
    },
    {
        "page": 58,
        "text": "코드의 80번째 라인을 보면 den에 2^-9을 하고 82번째\n라인에서 num의 결과와 den의 결과를 더한 것을 볼 수\n있다. 그런데 이 때의 num은 2^-9을 아직 하지 않은\n상태이다. 그러면 왜? den만 2^-9을 해 주고 num과\n더했을까?\n그것은 2^-9을 하지 않은 num이 den의 입력이여서 den을 통과하고 나온 신호는 2^-18이 되기 때문이다.\n a a a 84번째 라인에서는 계수중에 음수가 있었기 때문에 전체적으로 signed 연 산이 이루어져 결과물의 최상위 비트는 부호를 나타낸다. 이 필터의 출력은 unsigned 로 설계할 것이므로 혹시나 음으로 나온 값은 0으로 수렴토록 하고 10bit을 초과하는 값에 대해서는 10bit의 최대값인 1023으로 수렴토록 하였다.\n\n79\n80 wire [24:0] den_tot2 den_tot [33:9];\n81\n82 wire [25:0] num_den_sun = {12'd0, num_tot) + [den_tot2 [24] den_tot2};\n83\n84 assign pre_dout num_den_sun [25] ) ? 21'd0\n85 num_den_sum [24:21]) ? 21\"h1FFFFF num_den_sum [20:0] ;\n86\n87 reg [9:0] dout;\n88 always G (posedge clk or negedge rstb) begin\n89 if (!rstb) dout 10'do;\n90 else dout ( pre_dout [20]) ? 10'do\n91 pre_dout [19]) ? 10'd1023 pre_dout [18:9];\n92 end\n93\n94 endmodule"
    },
    {
        "page": 59,
        "text": "3.3 Testbench 분석\nverilog 로 설계한 필터를 테스트하기 위해서는 testbench\n라고 불리는 verilog 파일을 작성해야 한다. 앞에서 우리가\n설계한 필터를 설계하기 위한 testbench 전체 코드를 다음\n페이지에 나타내었다."
    },
    {
        "page": 60,
        "text": "1\n2 'timescale 1ns /10ps\n3\n4\n5 module tb_dump;\n6\n7 reg rstb;\n8 wire [9:0] dout;\n9\n10\n11 reg [9:0] nemory [0:2000-1];\n12 initial begin\n13 $readmemh (*./IN/chirp_10bit2.txt\" memory) ;\n14 end\n15\n16 // 27MHz Clock Generate\n17 reg clk;\n18 always begin\n19 clk 介 1'b0; #(37/2.0);\n20 clk 介 1'b1; #(37/2.0);\n21 end\n22\n23 reg [31:0] cnt;\n24 always ⌀( posedge clk or negedge rstb) begin\n25 if (!rstb) cnt <= 32'b0;\n26 else cnt 介 cnt + 1'b1;\n27 end\n28\n29 wire [9:0] din_pre nemory [cnt];\n30\n31 reg [9:0] din;\n32 always ⌀(posedge clk or negedge rstb) begin\n33 if (Irstb) din 介 (10(1'b0));\n34 else din <= din_pre;\n35 end\n36\n37\n38 iir_lpf1p2m uIIR_LPF1P2M (\n39 clk (clk)\n40 rstb (rstb)\n41 din (din) ,\n42 dout (dout)\n43 ) ;\n44",

        "text1" : "~",
    },
    {
        "page": 61,
        "text": "45\n46\n47 integer file1;\n48 always (posedge clk) begin\n49 if (cnt >= 32'd10) $fdisplay (file1 \"%d\" din) ;\n50 end\n51\n52 integer file2;\n53 always @(posedge clk) begin\n54 if (cnt >= 32'd10) $fdisplay (file2 \"%d\" dout) ;\n55 end\n56\n57 initial begin\n58 file1 = $fopen (\" /din.txt\");\n59 file2 = $fopen (\" /dout.txt\");\n60 rstb 介 1\"b0;\n61 #(37/2);\n62 rstb 1'b1;\n63 #(2000*37) ;\n64 $fclose (file1) ;\n65 $fclose (file2) ;\n66 $finish;\n67 end\n68\n69 endmodule\ntestbench 는 여기까지 두 페이지에 결쳐 소개되었다. 이제\ntestbench 를 부분적으로 살펴보도록 하자."
    },
    {
        "page": 62,
        "text": "chirp_10bit. txt 라는 파일은 chirp 신호를 덤프 받은\n파일이다. 이 파일은 앞에서 python 프로그램으로 덤프받은\n것인데, 아래는 chirp 파일을 verilog 로 읽어서 메모리에\n저장하고 데이터를 하나씩 꺼내어 필터의 입력으로 주는\n코드를 보이고 있다.\nreg [9:0] memory [0:2000-1];\ninitial beg in\n$readmemh (\" ./IN/chirp_10bit. txt\" memory);\nend\nwire [9:0] din pre memory [cnt] ;\nreg [9 :0] din;\nalways (posedge clk or negedge rstb) begin\nif ( !rstb) din 介 (10(1'b0) } ;\nelse din 介 din_pre;\nend"
    },
    {
        "page": 63,
        "text": "테스트 벤치(testbench) 의 중간 부분에 verilog 로 설계한\n필터를 불러오는 부분이 있다. 아래 그림과 같이 표현된\n부분이 우리가 설계한 필터이다. uIIR_LPF1P2M 으로\n가명을 써서 불러 들인 것도 관찰할 수 있다.\n3 \n38 iir_lpf1p2m uIIR_LPF1P2M\n39 clk (clk)\n40 rstb (rstb)\n41 din (din)\n42 dout (dout)\n43\n44"
    },
    {
        "page": 64,
        "text": "필터의 입력과 출력을 모두 파일로 덤프(dump) 받는\n부분이다. 이렇게 파일로 덤프 받는 이유는 python 으로\n설계한 필터와 verilog 로 설계한 필터를 서로 비교하기\n위해서인데, 서로의 입력과 출력을 비교하여 두 필터가\n같은지 알아보려고 한다.\ninteger file1 ;\nalways (posedge clk) begin\nif (cnt >= 32'd10) $fdisplay (file1 \"%d\", din) ;\nend\ninteger file2\nalways (posedge clk) begin\nif (cnt >= 32'd10) $fdisplay (file2 \"%d\", dout) ;\nend\ninitial begin\nfile1 = $fopen (\" /din.txt\") ;\nfile2 = $fopen (\" /dout.txt\") ;\nrstb <= 1'b0;\n#(37/2) ;\nrstb 1'b1;\n# (2000*37) ;\n$fclose (file1) ;\n$fclose (file2 ) ;\n$finish\nend"
    },
    {
        "page": 65,
        "text": "앞에서 테스트벤치를 돌려서 얻은 입력과 출력 파일을 다시\n파이션으로 불러와서 파이션에서 줬던 입력과 필터의 출력을\n비교하는 스크립트 전체를 나누어서 수록해 놓았다.\n4 from numpy import log10, arange, pi, linspace\n5 from scipy import diff\n6 from scipy signal import *\n7 from mathwang import *\n8\n9\n10 ## FIR Filter Or IIR Filter\n11\n12 ntap = 3\n13 units = 1e6\n14 op_hz = 27 * units\n15 fc = 1.2 * units\n16\n17\n18 Fc_Freq = fc / (0.5*op_hz)\n19\n20 num, den-iirfilter(N=ntap, Wn=[Fc_Freq], rp=0.1 rs=60,\n21 btype= . lowpass , ftype= bessel analog=⌀, output= ba' )\n22\n23 num den-quen_coeff_auto_iir(num, den, 9)\n24\n25 W h=freqz(num,den)\n26 mag=20 * log10 (abs(h))\n27 phase=unwrap(angle(h) )*180/pi\n28 grodly-diff(unwrap(angle(h)))/diff(w)\n29"
    },
    {
        "page": 66,
        "text": "30\n31\n32 t=arange(1024)*(37e-9)\n33 chirp_sig = 511* chirp(t, f0 0, t1=1023*(37e-9), f1 6e+6, method='linear' phi ⌀)+512\n34\n35 fn = open⌀ chirp 10bit . txt 'w')\n36 for val in chirp_sig:\n37 fn.write('%3x\\n'%val)\n38 fn.close()\n39\n40 filter_in=[]\n41 fn open chirp_10bit txt 'r')\n42 for val in fn. readlines():\n43 filter_in. append(int(val,16))\n44 fn.close⌀\n45\n46\n47 filter_out = lfilter(num, den, filter_in)\n48\n49\n50 fn1 ■ open( din2.txt r')\n51 din=[]\n52 for i in fn1. readlines⌀ :\n53 i=i. strip()\n54 if i != or i !=\n55 din. append(int(i))\n56 else:\n57 din. append ( 1⌀24)\n58 fn1.close()\n59\n60\n61 fn2 = open(*dout2.txt 'r')\n62 dout=[]\n63 for i in fn2. readlines⌀:\n64 i-i. strip()\n65 if i != or i !=\n66 dout append(i)\n67 else:\n68 dout . append(1024)\n69 fn2.close()\n70\nchirp_sig 은 0~6MHz주파수 성분을 갖고 range가\n1~1023인 신호이다. 이 신호를 chirp_10bit. txt로 저장한\n뒤 다시 읽어 filter _in에 대입하였다. filter _in 은 num,\nden 으로 구성된 필터(lfilter) 로 들어가 filter _out이란\n신호로 출력된다. 그 다음에는 filter in과 filter_out을\nverilog 테스트벤치에서 뽑은 파일들 (din2. txt, dout2.txt)\n과 비교하기 위해 이들 파일을 불러오고 있다."
    },
    {
        "page": 67,
        "text": "71\n72 figure(3)\n73 title verilog simulation )\n74 hold(True)\n75 plot(filter_in[9:])\n76 hold(True)\n77 plot (din, 'r-\n78 ylim([-2,1026] )\n79 grid(True)\n80\n81\n82 figure(4)\n83 title verilog simulation )\n84 hold(True)\n85 plot(floor (filter_out[8:]))\n86 hold(True)\n87 plot(dout, 'r--')\n88 ylim([-2,1026])\n89 grid(True)\n90\n91 show()\n92\nverilog 의 입력은 din이고 python 의 입력은 filter in\n이다. 이 둘을 figure(3)에서 비교하였고 verilog 의 출력\n인 dout과 python 출력 filter _out은 figure(4)에 비교하\n도록 하였다."
    },
    {
        "page": 68,
        "text": "plot 할 때 hold() 함수를 사용하면, 두 신호를 중첩해서\nplot 할 수 있다. 또한 plot() 함수에 r - 와 같은 인수를\n주게 되면 신호의 색상 뿐만 아니라 파형 (waveform) 의\n모양까지 바꿀 수 있다.\n71\n72 figure(3)\n73 title verilog simulation' )\n74 hold(True)\n75 plot (filter_in[9:])\n76 hold(True)\n77 plot (din, 'r--\n78 ylim([-2,1026] )\n79 grid(True)\n80\n81"
    },
    {
        "page": 69,
        "text": "아래는 파이션으로 설계한 필터의 입력과 verilog 로 설계한\n필터의 입력을 서로 중첩해서 plot 한 그림이다. 입력\nstimulus 가 서로 동일하다는 것을 보여주기 위해 확대한\n것을 아래 그림에 나타내었다. 이것은 software (python)\n으로 설계한 것과 hardware (verilog) 로 설계된 것에\n똑같은 입력을 넣어주고 있다는 것을 의미한다.\nverilog simulation\n1000\n800\n600\n400\n200\n200 400 600 800 1000 1200\nverilog simulation\n1000\n900\n800\n700\n600\n100 150 200 250 300\nzoom rect"
    },
    {
        "page": 70,
        "text": "다음은 각각 python 과 verilog 로 설계한 필터의 출력을\n서로 비교하여 plot 한 것이다. 두 출력이 동일한 것을\n보여주고 있다. 이렇게 두 출력이 동일해야 python 으로\n설계한 필터가 verilog 로 잘 설계되었다고 할 수 있다.\nverilog simulation\n1000\n800\n600\n400\n200\n200 400 600 800 1000 1200\nverilog simulation\n650\n600\n550\n500\n450\n400\n350\n260 280 300 320 340\nzoom rect"
    },
    {
        "page": 71,
        "text": "4: Appendix A"
    },
    {
        "page": 72,
        "text": "1 #! /usr/bin/python\n2\n3 import math\n4\n5 def plus_minus(n) :\n6 if n >= 0:\n7 return \"plus\"\n8 else:\n9 return \"minus\"\n10\n11 def int_frac(n) --\n12 return int (n), n-int(n)\n13\n14 def quen(n, max=9):\n15 sign plus_minus (n)\n16 i,f=int_frac(n)\n17 1t=[]\n18\n19 for j in xrange (max,⌀,-1):\n20 j=(j-1)\n21 if abs(i) >= 2*j:\n22 i abs(i)-2 j\n23 lt,append(j)\n24 else:\n25 pass\n26\n27 for V in range (max):\n28 V=-1* (Ⓥ+1)\n29 if abs (f) >= 2** V:\n30 f abs(f)-2**v\n31 lt.append(v)\n32 else:\n33 pass\n34\n35 sum=0\n36 for 11 in lt:\n37 sum=sum+2**11\n38\n39 if sign== \"minus\":\n40 result=-1*sum\n41 else:\n42 result=sum\n43\n44 return result\n45\n46 def iir_quen(num, max=9):\n47 1t=[]\n48 for n in num:\n49 1t,append(quen(n,max))\n50 return 1t\n51"
    },
    {
        "page": 73,
        "text": "51\n52 def quen_coeff_auto_iir(num,den,max) :\n53 num=iir_quen(num,max)\n54 den iir_quen (den,max)\n55 endn=1en num)-1\n56 diff=sum( num)-sum(den)\n57 diff_half=diff/2\n58 num 0 =num 0 -diff_half\n59 num[endn]=num[endn]-diff_half\n60\n61 return num,den\n62\n63\n64 def pow2_print(num, max=9) :\n65 for n in num:\n66 sign=plus_minus (n)\n67 i f int_frac(n)\n68 1t=[]\n69\n70 for j in xrange(max,0,-1):\n71 j=(j-1)\n72 if abs(i) >= 2 j:\n73 i abs(i)-2 j\n74 lt⌀append(j)\n75 else:\n76 pass\n77\n78 for V in range(max):\n79 V=-1* (Ⓥ+1)\n80 if abs(f) 2**v:\n81 f abs (f)-2**v\n82 lt.append (v)\n83 else:\n84 pass\n85\n86\n87 txt=\"%32.32f\"%n\n88 print txt.rstrip('0')+\" -->\",1t\n89"
    },
    {
        "page": 74,
        "text": "IIR Digital Filter 설계\n( with Python )\n왕 윤성 저.\nitr (din):\nden SUR-\ndout- ⌀,@,@\nfor  in xrange (1en (din)):\nf>2:\nmule 0.001953125 din 11 din[i-3])\nmull 0.005859375 (din[1-1] din[1-2])\nden_sum mule mull\nbeul⌀ 2.357421875 dout f⌀1\nbmull 1.87\nbmu12  Figure 2\nsue bmule\npre_ dout den_\npython iir simulation\ndout .append pre\nreturn dowt 1000\nTHE Filter\ntap\n800\nunits led\nop_hz 24 units\nc 1.2 units\nc_Freg s⌀op - 600\nnum den-firfilter Wenter,\nbtype- 10ml\ndenequen_ coeff auto fir\n400\n⌀h freqz num den\n대표-20+ legie abs \"\nphase unwr - angle h))+180\ngrpdlys-diff unwrap angle 200\nt-arange 1024)*(37e=9\nchirp_sig 511 chir⌀ t\ndout-lir chirp_sig 200 400 600 800\nfigure(2)\ntitle python 址 simulatio\nnold (True) +\nplot(chirp_sig)\ndin[9:0] dout[9:0]\nb0\nD\nb1 + + -a0\nb2 + + -a1\nb3 -a2\n고가의 상용 프로그램을 사용하지 않아도 Python 을 사용하면\n실무에서 사용할 수 있는 디지털 필터를 설계할 수 있다.\nScipy, Numpy, Matplotlib 과 같은 훌륭한 패키지를 사용하면\n고가의 상용툴과 거의 동일한 결과를 얻을 수 있다.\n투마이북"
    }
]